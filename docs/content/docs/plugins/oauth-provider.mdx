---
title: oAuth 2.1 Provider
description: A Better Auth plugin that enables your auth server to serve as an oAuth 2.1 provider.
---

An **oAuth 2.1 Provider Plugin** that allows you to turn your authentication server into an oAuth provider with OIDC compatability allowing users and other services to authenticate with your API.

The plugin has a secured configuration by default providing ease to users unfamiliar with the details of oAuth.

<Callout type="info">
Please report any issues or bugs on [GitHub](https://github.com/better-auth/better-auth).
</Callout>

**Key Features**:

- **oAuth 2.1**: Restricted security practices to [oAuth 2.1](https://oauth.net/2.1/)
- **OIDC compatability**: [OIDC](https://openid.net/specs/openid-connect-core-1_0.html)-compliant with the `openid` scope
  - **UserInfo**: Endpoint providing current user details
  - **id_token**: JWT-signed user information
- **Dynamic Client Registration**: Allow clients to register applications dynamically.
  - **Public Clients**: Support public clients for native mobile applications and user-agent applications (like AI)
  - **Confidential Clients**: Supports confidential clients for web applications
  - **Trusted Clients**: Configure hard-coded trusted clients with optional consent bypass.
- **JWT Plugin compatability**: required by default with an option to disable
  - **JWT Signing**: sign JWT tokens when requesting a `resource`
  - **JWKS Verifiable**: verify tokens remotely at the [`/jwks`](/docs/plugins/jwt#verifying-the-token) endpoint
- **Authorization Prompts**: prompts that initiate specific login flows
  - **Consent**: Ensure consent is granted for each scope.
- **Resource Endpoints**: Read and manage tokens.
  - **Introspection**: [RFC7662](https://datatracker.ietf.org/doc/html/rfc7662)-compliant Introspection.
  - **Revocation**: [RFC7009](https://datatracker.ietf.org/doc/html/rfc7662)-compliant Revocation.
- **Sessions**: Successful login attempts create a `Session` which through other plugins can trigger hooks, such as welcome emails.

**Grants Supported**

- **authorization_code**: Code for user token exchange with PKCE and S256 requirements.
- **refresh_token**: Issue refresh tokens and handle access token renewal using `offline_access` scope.
- **client_credentials**: Machine to Machine tokens for API communication.


## Installation

<Steps>
  <Step>
    ### Mount the Plugin

    Add the OIDC plugin to your auth config. See [OIDC Configuration](#oidc-configuration) on how to configure the plugin.

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth";
    import { oauthProvider } from "better-auth/plugins";

    const auth = betterAuth({
      disabledPaths: [
        "/token",
      ],
      plugins: [
        jwt(),
        oauthProvider({
          loginPage: "/sign-in",
          consentPage: "/consent",
          // ...other options
        })
      ],
    });
    ```
  </Step>

  <Step>
    ### Migrate the Database

    Run the migration or generate the schema to add the necessary fields and tables to the database.

    <Tabs items={["migrate", "generate"]}>
      <Tab value="migrate">
      ```bash
      npx @better-auth/cli migrate
      ```
      </Tab>
      <Tab value="generate">
      ```bash
      npx @better-auth/cli generate
      ```
      </Tab>
    </Tabs>
    See the [Schema](#schema) section to add the fields manually.
  </Step>

  <Step>
    ### Add the Client Plugin

    Add the OIDC client plugin to your auth client config.

    ```ts
    import { createAuthClient } from "better-auth/client";
    import { oauthProviderClient } from "better-auth/client/plugins"
    const authClient = createAuthClient({
      plugins: [oauthProviderClient()],
    });
    ```
  </Step>

  <Step>
    ### Disable the "/token" endpoint

    To make your plugin oAuth compliant, you **MUST** disable the `/token` endpoint enacted by the JWT plugin, the OAuth equivalent is located at [`/oauth2/token`](#token-endpoint) instead.

    ```ts title="auth.ts"
    const auth = betterAuth({
      disabledPaths: [
        "/token",
      ],
    });
    ```
  </Step>

  <Step>
    ### Add `./well-known` endpoints

    Recommended, please add all [Well Known endpoints](#well-known) to the root configuration of your project.

    - You **MUST** add the oAuth Authorization Server metadata endpoint at your issuer path (root if no path).
    - If you are using the `openid` scope, you **MUST** add the openid configuration at your issuer path (root if no path).
    - If you are using the resource server (ie for MCP), you **MUST** add the resource server metadata to your API, with the issuer path appended.

  </Step>
</Steps>


## Usage

The plugin operates as an oAuth 2.1 server with OIDC compatable endpoints and JWT verifiable access tokens. The following provides more detailed information about each endpoint.

### Register Endpoint

<Callout type="info">
This endpoint supports [RFC7591](https://datatracker.ietf.org/doc/html/rfc7591) compliant client registration.
</Callout>

Once installed, you can utilize the OAuth Provider to manage authentication flows within your application.

After the application is created, you will receive a `client_id` and `client_secret` that you can display to the user. The `client_secret` can only be provided once, ensure the user saves it.

#### Setup

To enable client registration set `allowDynamicClientRegistration: true` in your BetterAuth config.

```ts title="auth.ts"
oidcProvider({
  allowDynamicClientRegistration: true,
  // ... other options
})
```

To enable unauthenticated client registration which allows for dynamically registered public clients, additionally set `allowUnauthenticatedClientRegistration: true` in your BetterAuth config.

```ts title="auth.ts"
oidcProvider({
  allowDynamicClientRegistration: true,
  allowUnauthenticatedClientRegistration: true,
  // ... other options
})
```

#### Simple Example

To register a new OIDC client, use the `oauth2.register` method.

```ts
const application = await client.oauth2.register({
  client_name: "My Client",
  redirect_uris: ["https://client.example.com/callback"],
});
```

#### Full Method

<APIMethod path="/oauth2/register" method="POST">
```ts
type registerOAuthApplication = {
  /**
   * A list of redirect URIs. 
   */
  redirect_uris: string[] = ["https://client.example.com/callback"]
  /**
   * The authentication method for the token endpoint. 
   */
  token_endpoint_auth_method?: "none" | "client_secret_basic" | "client_secret_post" = "client_secret_basic"
  /**
   * The grant types supported by the application. 
   */
  grant_types?: ("authorization_code" | "client_credentials" | "refresh_token")[] = ["authorization_code"]
  /**
   * The response types supported by the application. 
   */
  response_types?: ("code")[] = ["code"]
  /**
   * The name of the application. 
   */
  client_name?: string = "My App"
  /**
   * The URI of the application. 
   */
  client_uri?: string = "https://client.example.com"
  /**
   * The URI of the application logo. 
   */
  logo_uri?: string = "https://client.example.com/logo.png"
  /**
   * The scopes supported by the application. Separated by spaces. 
   */
  scope?: string = "profile email"
  /**
   * The contact information for the application. 
   */
  contacts?: string[] = ["admin@example.com"]
  /**
   * The URI of the application terms of service. 
   */
  tos_uri?: string = "https://client.example.com/tos"
  /**
   * The URI of the application privacy policy. 
   */
  policy_uri?: string = "https://client.example.com/policy"
  /**
   * The software ID of the application. 
   */
  software_id?: string = "my-software"
  /**
   * The software version of the application. 
   */
  software_version?: string = "1.0.0"
  /**
   * The software statement of the application. 
   */
  software_statement?: string
  /**
   * The metadata of the application. 
   */
  metadata?: Record<string, any> = {"key": "value"}
}
```
</APIMethod>


### Authorize Endpoint

An [OAuth 2.1 authorization endpoint](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#name-authorization-endpoint). Since many of the details are not yet fully described, parts are adapted from the legacy [OAuth 2.0 Authorization Endpoint Section](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1) but always implements the [differences from OAuth 2.0](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13#name-differences-from-oauth-20).

The Authorization Endpoint is the entry point for initiating an OAuth 2.1 authorization flows, requiring the grant type `authorization_code` in the options grant types list.

#### Simple Example

To register a new OIDC client, use the `oauth2.register` method.

```ts
const application = await client.oauth2.authorize({
  response_type: "code", // required
  client_id: "my_client", // required
  redirect_uri: "https://client.example.com/callback", // required
  scope: "openid profile email offline_access",
  state: "123", // recommended (ex: randomBytes(32).toString('base64url'))
  code_challenge_method: "S256", // required
  code_challenge: "456789",
});
```

#### Full Method

<APIMethod path="/oauth2/authorize" method="POST">
```ts
type authorizeOAuth = {
  /**
   * Authorization processing flow being used
   */
  response_type: string = "code",
  /**
   * Client Id issued by the Authorization Server during registration.
   */
  client_id: string = "my_client",
  /**
   * Redirect uri to return to after the request
   */
  redirect_uri: string = "https://client.example.com/callback",
  /**
   * Space-separated list of requested scopes.
   */
  scope: string = "openid profile email offline_access",
  /**
   * Recommended random state used to mitigate CSRF attacks
   */
  state?: string = "https://client.example.com/callback",
  /**
   * Challenge derived from the code verifier
   */
  code_challenge: string = "123",
  /**
   * Method used to derive code_challenge
   */
  code_challenge_method: string = "S256",
  /**
   * nonce value
   */
  nonce?: string = "123",
  /**
   * Assert whether the server should prompt a specific authentication flow
   */
  prompt?: ["none" | "login" | "consent"] = "none",
}
```
</APIMethod>

#### Parameters

**State**

We recommend sending a state to mitigate cross-site request forgery (CSRF) attacks. This works by ensuring your client only responds to requests that your client initially requested.

Generate a state value from your client and store on your client such as in a secure, HTTP-only cookie or database.

**Code Challenge**

Code challenges helps protect the authorization `code` returned from the authorization endpoint.

To do so, a code challenge is derived from the code verifier, used and sent in a [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) to the Authorization Server.

**Example**

```ts
import { randomBytes, createHash } from 'crypto'

const state = randomBytes(32).toString('base64url');
const codeVerifier = randomBytes(32).toString('base64url');
const codeChallenge = createHash("SHA-256")
  .update(codeVerifier)
  .digest()
  .toString('base64url');

const stateData = {
  codeVerifier,
  state,
  redirectUri: '/dashboard',
};

// pseudocode set cookie
await signedCookie(
  "__Secure-auth.client-state",
  JSON.stringify(stateData), {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 3600,
    path: '/api/auth/oauth2/',
  }
);
```

Now at your `redirect_uri`, check to see if the returned state matches the initial state.

```ts
// pseudocode get cookie
const stateCookie = JSON.parse(
  (await getSignedCookie("__Secure-auth.client-state")) ?? '{}',
);

// Compare states if returned
if (stateCookie?.state !== query?.state) {
  throw new Error('Login state does not match.')
}

const tokens = await client.oauth2.token({
  client_id: "my_client", // required
  client_secret: "my_client_secret", // required for confidential clients
  grant_type: 'authorization_code',
  code: codeQuery,
  code_verifier: stateCookie.codeVerifier,
});
```


### Token Endpoint

By default, the token endpoint supports providing tokens for the following grants:

- "authorization_code"
- "client_credentials"
- "refresh_token"

#### Authorization code grant

The authorization code grant enables clients to obtain access user access tokens and optionally refresh tokens (with the "offline_access" scope).

#### Client credentials grant

The client credentials grant enables clients to obtain machines to obtain access tokens.

#### Refresh token grant

The refresh token grant enables clients to update their access token without needing the user to login again.


### Consent Endpoint

Accept or deny user consent for a set of scopes.

<APIMethod path="/oauth2/consent" method="POST">
```ts
type authorizeOAuth = {
  /**
   * Accept or deny user consent for a set of scopes
   */
  accept: boolean = true,
}
```
</APIMethod>

### Introspect Endpoint

[RFC7662](https://datatracker.ietf.org/doc/html/rfc7662)-compliant Introspection.

This endpoint provides details of the provided token. If the token is additionally tied to a session, the endpoint will ensure the session is `active`.

<APIMethod path="/oauth2/introspect" method="POST">
```ts
type introspectOAuth = {
  /**
   * Client Id.
   */
  client_id: string = "my_client",
  /**
   * Client Secret.
   */
  client_secret: string = "my_client_secret",
  /**
   * An access token or refresh token
   */
  token: string = "xyz",
  /**
   * Type of token when known.
   */
  token_type_hint?: "access_token" | "refresh_token" = "access_token",
}
```
</APIMethod>

### Revoke Endpoint

[RFC7009](https://datatracker.ietf.org/doc/html/rfc7662)-compliant Revocation.

This endpoint revokes the provided token.

- opaque `access_token`: immediately removes that `access_token` from the database. `refresh_token` is still valid.
- JWT `access_token`: verifies that token is safe to remove from client storage.
- `refresh_token`: removes all `access_tokens` granted using that `refresh_token` and removes the `refresh_token` to prevent further token issuance.

For an `access_token` type, 

<APIMethod path="/oauth2/introspect" method="POST">
```ts
type introspectOAuth = {
  /**
   * Client Id.
   */
  client_id: string = "my_client",
  /**
   * Client Secret.
   */
  client_secret: string = "my_client_secret",
  /**
   * An access token or refresh token
   */
  token: string = "xyz",
  /**
   * Type of token when known.
   */
  token_type_hint?: "access_token" | "refresh_token" = "access_token",
}
```
</APIMethod>

### UserInfo Endpoint

The UserInfo Endpoint provides [OIDC](https://openid.net/specs/openid-connect-core-1_0.html)-compliant user information. Available at `/oauth2/userinfo`, the endpoint requires a valid access token with at least the scope `openid`.

<Endpoint path="/oauth2/userinfo" method="GET" />
```ts title="client-app.ts"
// Example of how a client would use the UserInfo endpoint
const response = await fetch('https://your-domain.com/api/auth/oauth2/userinfo', {
  headers: {
    'Authorization': 'Bearer ACCESS_TOKEN'
  }
});

const userInfo = await response.json();
// userInfo contains user details based on the scopes granted
```

The UserInfo endpoint returns different claims based on the scopes that were granted during authorization:

- `openid`: Returns the user's ID (`sub` claim)
- `profile`: Returns `name`, `picture`, `given_name`, `family_name`
- `email`: Returns `email` and `email_verified`

The `getAdditionalUserInfoClaim` function receives the user object, requested scopes array, and the client, allowing you to conditionally include claims based on the scopes granted during authorization. These additional claims will be included in both the UserInfo endpoint response and the ID token.


### Well known

#### Openid Configuration

Provides [OpenID connect discovery metadata](https://openid.net/specs/openid-connect-discovery-1_0.html) located at `/.well-known/openid-configuration`.

This endpoint requires the scope `openid`.

By default, Better Auth uses the base path `/api/auth`. It is recommended to additionally add the configuration at the root (specifically the issuer path).

NOTE: For issuers with paths, OpenId utilizes path appending, thus any path on the issuer should be prepended before `/.well-known/openid-configuration`.

```ts title="[issuer-path]/.well-known/openid-configuration/route.ts"
import { oAuthProviderOpenIdConfigMetadata } from "better-auth/plugins";
import { auth } from "@/lib/auth";

export const GET = oAuthProviderOpenIdConfigMetadata(auth);
```


#### oAuth Authorization Server

Provides [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414)-compliant metadata located at `/.well-known/oauth-authorization-server`.

By default, Better Auth uses the base path `/api/auth`. It is recommended to additionally add the configuration at the root (specifically the issuer path).

NOTE: For issuers with paths, oAuth 2.1 Authorization Server utilizes path insertion, thus any path on the issuer should be appended after `/.well-known/oauth-authorization-server`.

```ts title="/.well-known/oauth-authorization-server/[issuer-path]/route.ts"
import { oAuthProviderAuthServerMetadata } from "better-auth/plugins";
import { auth } from "@/lib/auth";

export const GET = oAuthProviderAuthServerMetadata(auth);
```


## Configuration


### Login Screen

When a user is redirected to the OIDC provider for authentication, if they are not already logged in, they will be redirected to the login page. You can customize the login page by providing a `loginPage` option during initialization.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  plugins: [oidcProvider({
    loginPage: "/sign-in"
  })]
})
```

You don't need to handle anything from your side; when a new session is created, the plugin will handle continuing the authorization flow.


### Consent Screen

When a user is redirected to the OIDC provider for authentication, they may be prompted to authorize the application to access their data. This is known as the consent screen. By default, Better Auth will display a sample consent screen. You can customize the consent screen by providing a `consentPage` option during initialization.

**Note**: Trusted clients with `skipConsent: true` will bypass the consent screen entirely, providing a seamless experience for first-party applications.

```ts title="auth.ts"
import { betterAuth } from "better-auth";

export const auth = betterAuth({
  plugins: [oidcProvider({
    consentPage: "/path/to/consent/page"
  })]
})
```

The plugin will redirect the user to the specified path with `consent_code`, `client_id` and `scope` query parameters. You can use this information to display a custom consent screen. Once the user consents, you can call `oauth2.consent` to complete the authorization.

<Endpoint path="/oauth2/consent" method="POST" />

The consent endpoint supports two methods for passing the consent code:

**Method 1: URL Parameter**
```ts title="consent-page.ts"
// Get the consent code from the URL
const params = new URLSearchParams(window.location.search);

// Submit consent with the code in the request body
const consentCode = params.get('consent_code');
if (!consentCode) {
	throw new Error('Consent code not found in URL parameters');
}

const res = await client.oauth2.consent({
	accept: true, // or false to deny
	consent_code: consentCode,
});
```

**Method 2: Cookie-Based**
```ts title="consent-page.ts"
// The consent code is automatically stored in a signed cookie
// Just submit the consent decision
const res = await client.oauth2.consent({
	accept: true, // or false to deny
	// consent_code not needed when using cookie-based flow
});
```

Both methods are fully supported. The URL parameter method works well with mobile apps and third-party contexts, while the cookie-based method provides a simpler implementation for web applications.


### Trusted Clients

For first-party applications and internal services, you can configure trusted clients directly in your OIDC provider configuration. Trusted clients bypass database lookups for better performance and can optionally skip consent screens for improved user experience.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

const auth = betterAuth({
  plugins: [
    oidcProvider({
      loginPage: "/sign-in",
      trustedClients: [
        {
          clientId: "internal-dashboard",
          clientSecret: "secure-secret-here",
          name: "Internal Dashboard",
          type: "web",
          redirectURLs: ["https://dashboard.company.com/auth/callback"],
          disabled: false,
          skipConsent: true, // Skip consent for this trusted client
          metadata: { internal: true },
        },
        {
          clientId: "mobile-app",
          clientSecret: "mobile-secret", 
          name: "Company Mobile App",
          type: "native",
          redirectURLs: ["com.company.app://auth"],
          disabled: false,
          skipConsent: false, // Still require consent if needed
          metadata: {},
        },
      ]
  })]
})
```

### Scopes

Scopes allow clients specific access to specific resources.
By default, we support the following scopes are supported:

- `openid`: Returns the user's ID (`sub` claim).
- `profile`: Returns name, picture, given_name, family_name
- `email`: Returns email and email_verified
- `offline_access`: Returns a refresh token

The scopes configuration can contain as many or as few scopes as you wish! Note that `openid` is required to be considered an OIDC server, otherwise this is a standard OAuth 2.1 server. All supported scopes must be in this array.

```ts title="auth.ts"
oidcProvider({
  scopes: [ "openid", "profile", "offline_access", "read:post", "write:post" ],
})
```

### Claims

Claims are fields defined in your access and id tokens. You can add more claims using the `customClaims`.

By internally, we support the following claims are supported: ["sub", "iss", "aud", "exp", "nbf", "iat", "jti", "sid", "scope", "azp"].

The claims configuration can only be appended to the internal supported claims. Claims should be namespaced when possible to avoid potential future conflicts.

```ts title="auth.ts"
oidcProvider({
  customClaims: [ "locale", "https://example.com/roles" ],
  // Attach claims to id tokens
  customIdTokenClaims: (_user: User, _scopes: string[]) => {
    return {
      locale: "en-GB",
    };
  },
  // Attach claims to access tokens
  customJwtClaims: (_user: User, _scopes: string[]) => {
    return {
      "https://example.com/roles": ["admin", "editor"],
    };
  },
  // Additional user info claims
  getAdditionalUserInfoClaim: (_user: User, _scopes: string[]) => {
    return {
      locale: "en-GB",
      "https://example.com/roles": ["admin", "editor"],
    };
  },
})
```

### Expirations

Each token type and grant type can independently can set a default expiration.

- `accessTokenExpiresIn` defaults 1 hour
- `m2mAccessTokenExpiresIn` defaults 1 hour
- `idTokenExpiresIn` defaults 10 hours
- `refreshTokenExpiresIn` defaults 30 days
- `codeExpiresIn` defaults 10 minutes

Additionally, Access Tokens can set lower expirations based on scopes. This is useful for higher-privelege scopes that require shorter expiration times. The earliest expiration will take precendence. If not specified, the default will take place. Note: values should be lower than the defaults `accessTokenExpiresIn` and `m2mAccessTokenExpiresIn`.

```ts title="auth.ts"
oidcProvider({
  scopeExpirations: {
    "write:payments": "5m",
    "read:payments": "30m",
  },
})
```


### Registration

#### Dynamic Client Registration

Dynamic registration allows for authorized registration of both public and confidential clients.

```ts title="auth.ts"
oidcProvider({
  allowDynamicClientRegistration: true,
})
```

Unauthenticated client registration additionally allows for public clients (never confidential) to register without an authorization header. This is especially useful for an MCP to dynamically register themselves as a public client.

```ts title="auth.ts"
oidcProvider({
  allowDynamicClientRegistration: true,
  allowUnauthenticatedClientRegistration: true,
})
```

#### Dynamic Client Registration Expiration

You can additionally set an expiration time for how long a confidential client should last for. By default, dynamically registered confidential clients do not expire.

```ts title="auth.ts"
oidcProvider({
  allowDynamicClientRegistration: true,
  clientRegistrationClientSecretExpiration: "30d",
})
```

#### Dynamic Client Registration Scopes

To set a list of default scopes for newly registered clients when scopes parameter is not sent, set the `clientRegistrationDefaultScopes` field. All scopes must be defined in `scopes`.

```ts title="auth.ts"
oidcProvider({
  scopes: ["reader", "editor"],
  clientRegistrationDefaultScopes: ["reader"],
})
```

To also set a list of allowed scopes for newly registered clients when scopes parameter is not sent, set the `clientRegistrationAllowedScopes` field. These are **in addition** to the `clientRegistrationDefaultScopes`. All scopes must be defined in `scopes`.

```ts title="auth.ts"
oidcProvider({
  scopes: ["reader", "editor"],
  clientRegistrationDefaultScopes: ["reader"],
  clientRegistrationAllowedScopes: ["editor"],
})
```


### Storage

By default all secrets are `hashed` by default on the database. This helps protect the `client_secret` in case of a database leak.

- **storeClientSecret**: the storage method of application `client_secrets`. Only when `disableJWTPlugin: true`, the client secret shall rather be `encrypted`.
- **storeTokens**: the storage method of token values, specifically session refresh tokens and opaque access tokens.


### Refresh Token Customization

You can choose to format your session tokens in a different string format using the `encodeRefreshToken` and `decodeRefreshToken` functions.

These functions allow you to add additional functionality on the refresh token itself such as refresh token encryption or storage for session replay attacks.

If defined, both `encodeRefreshToken` and `decodeRefreshToken` functions. must be defined.

Example with change in refresh token format with backwards compatablity with original token-only format:

```ts title="auth.ts"
oidcProvider({
  encodeRefreshToken: (token, session) => {
    const res = session ? `1.${token}.${session}` : token;
    return res;
  },
  decodeRefreshToken: (token) => {
    const tokenSplit = token.split('.');
    if (tokenSplit.length === 3 && tokenSplit.at(0) === '1') {
      return {
        token: tokenSplit.at(1),
        sessionId: tokenSplit.at(2),
      };
    }
    return { token };
  },
})
```

Pseudocode for a token encryption:

```ts title="auth.ts"
import { CompactEncrypt, compactDecrypt } from 'jose'

const secret = "SOME_SECRET_OR_KEY"
const alg = "A256KW"
const enc = "A256GCM"

const auth = betterAuth({
  plugins: [oidcProvider({
    encodeRefreshToken: (token, session) {
      const value = JSON.stringify({
        sessionId: session.id,
        token,
      });
      const jwe = await new CompactEncrypt(Buffer.from(value))
        .setProtectedHeader({ alg, enc })
        .encrypt(secret);
      return jwe;
    },
    decodeRefreshToken: (token) {
      const { plaintext } = await compactDecrypt(token, secret);
      const payload = new TextDecoder().decode(plaintext);
      return JSON.parse(payload);
    },
  })]
})
```


### Advertised Metadata

The metadata endpoint can be customized so that the publicized scopes and claims differ from those which the server can deliver. This can prevent showcasing all your supported scopes and claims on your metadata endpoint.

All scopes and claims inside the advertisedMetadata section MUST be listed in `scopes` and `customClaims` respectively otherwise initialization will fail.

#### Scopes

```ts title="auth.ts"
oidcProvider({
  scopes: ["openid", "profile", "email", "offline_access", "read:post"],
  advertisedMetadata: {
    scopes_supported: ["openid", "profile", "read:post"],
  },
})
```

#### Claims

Claims are in addition to the internally supported claims which are automatically determined by `scopes`.

```ts title="auth.ts"
oidcProvider({
  claims_supported: ["https://client.example.com/roles"],
  advertisedMetadata: {
    claims_supported: ["https://client.example.com/roles"],
  },
})
```

### Disable JWT Plugin

By default, access and id tokens can be issued and verified through the JWT plugin.

You can disable the JWT requirement in which access tokens will always be opaque and id tokens are always signed in `HS256` using the `client_secret`. Note that disabling the JWT Plugin is still OIDC compliant, `/userinfo` still works and signed `id_token` is still provided.

Key Differences:
- Providing a valid `resource` will always provide you with an opaque access token instead of an JWT formatted token.
- `id_token` is not returned for public clients, but the `access_token` returned can still utilize the `/oauth2/userinfo` endpoint to obtain the user data.
- `id_token` for a confidential client is signed by their `client_secret`.

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oauthProvider } from "better-auth/plugins";

const auth = betterAuth({
  plugins: [
    oauthProvider({
      disableJWTPlugin: true,
      loginPage: "/sign-in",
      consentPage: "/consent",
      // ...other options
    })
  ],
});
```


### MCP

You can easily make your APIs MCP-compatabile simply by adding a resource server which directs users to this oAuth2.1 authorization server.

You cannot disable the JWT Plugin if you are utilizing this plugin.

#### Installation

<Steps>
  <Step>
    ### Ensure Well Known Paths are correct

    See [well-known endpoints](#well-known).
  </Step>

  <Step>
    ### Add oAuth Protected Resource Metadata to your API

    NOTE: For issuers with paths, oAuth 2.1 Authorization Server utilizes path insertion, thus any path on the issuer should be appended after `/.well-known/oauth-protected-resource`.

    - Automatic (if you have access to the better-auth configuration)

    ```ts title="/.well-known/oauth-protected-resource/[issuer-path]/route.ts"
    import { oAuthProviderProtectedResourceMetadata } from "better-auth/plugins";
    import { auth } from "@/lib/auth";

    export const GET = oAuthProviderProtectedResourceMetadata(auth);
    ```

    - Manual (without access to your better-auth configuration)

    Type support is recommended and may be downloaded into your API as a dev package.

    ```ts title="/.well-known/oauth-protected-resource/[issuer-path]/route.ts"
    import type { ResourceServerMetadata } from "better-auth";

    export const GET = async () => {
      const metadata: ResourceServerMetadata = {
        resource: "https://api.example.com", // must match the `aud` claim
      };

      return new Response(JSON.stringify(metadata), {
        headers: {
          "Content-Type": "application/json",
        },
      });
    };
    ```
  </Step>

  <Step>
    ### Handle MCP Errors for your API

    - Using `mcpHandler` helper

    ```ts title="api/[transport]/route.ts"
    import { auth } from "@/lib/auth";
    import { createMcpHandler } from "@vercel/mcp-adapter";
    import { mcpHandler } from "better-auth/plugins";
    import { z } from "zod";

    const handler = mcpHandler(auth, (req, session) => {
        // session contains the access token record with scopes and user ID
        return createMcpHandler(
            (server) => {
                server.tool(
                    "echo",
                    "Echo a message",
                    { message: z.string() },
                    async ({ message }) => {
                        return {
                            content: [{ type: "text", text: `Tool echo: ${message}` }],
                        };
                    },
                );
            },
            {
                capabilities: {
                    tools: {
                        echo: {
                            description: "Echo a message",
                        },
                    },
                },
            },
            {
                redisUrl: process.env.REDIS_URL,
                basePath: "/api",
                verboseLogs: true,
                maxDuration: 60,
            },
        )(req);
    });

    export { handler as GET, handler as POST, handler as DELETE };
    ```

    - Using `checkMcp` function

    We provide a generalized checker function as an alternative to `withMcpAuth` to check for an access token's validity.

    This function throws an error if not authenticated and **MUST** return the `www-authenticate` header manually. You can use the helper function `handleMcpErrors` to perform this automatically.

    ```ts
    import { auth } from "@/lib/auth"; // Location of BetterAuth options
    import { checkMcp, handleMcpErrors } from "better-auth/plugins";

    // this is pseudocode to show how to properly handle errors
    export const GET = async (req: Request) => {
      const accessToken = req.headers.get('Authorization');
      try {
        const tokens = await checkMcp({
          auth,
          accessToken,
          baseUrl,
        });
        // ...continue
      } catch (error) {
        try {
          return handleMcpErrors(error, {
            baseUrl: "https://auth.example.com/api/auth",
          });
        } catch (error) {
          console.error(error as unknown as string);
        }
      }
    }
    ```
  </Step>
</Steps>


## Schema

The OIDC Provider plugin adds the following tables to the database:

### OAuth Application

Table Name: `oauthApplication`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the OAuth client",
      isPrimaryKey: true
    },
    {
      name: "clientId",
      type: "string",
      description: "Unique identifier for each OAuth client",
      isPrimaryKey: true
    },
    {
      name: "clientSecret",
      type: "string",
      description: "Secret key for the OAuth client. Optional for public clients using PKCE.",
      isOptional: true
    },
    {
      name: "disabled",
      type: "boolean",
      description: "Field that indicates if the current application is disabled",
      isOptional: true,
    },
    {
      name: "scopes",
      type: "string[]",
      description: "Scopes this client is allowed to use",
      isOptional: true,
    },
    {
      name: "userId",
      type: "string",
      description: "ID of the user who owns the client. (optional)",
      isOptional: true
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was created" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the OAuth client was last updated"
    },
    {
      name: "name",
      type: "string",
      description: "Name of the OAuth client",
      isOptional: true,
    },
    {
      name: "uri",
      type: "string",
      description: "Website Uri displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "icon",
      type: "string",
      description: "Website Icon displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "contacts",
      type: "string[]",
      description: "Client contact list (ie customer service emails, phone numbers) to be displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "tos",
      type: "string[]",
      description: "Client Terms of Service displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "policy",
      type: "string[]",
      description: "Client Privacy policy displayed on UI Screens",
      isOptional: true,
    },
    {
      name: "softwareId",
      type: "string",
      description: "Client-defined software identifier. This should remain the same across multiple versions for the same piece of software.",
      isOptional: true,
    },
    {
      name: "softwareVersion",
      type: "string",
      description: "Client-defined version number of the softwareId.",
      isOptional: true,
    },
    {
      name: "softwareStatement",
      type: "string",
      description: "Signed JWT containing the software metadata as signed claims.",
      isOptional: true,
    },
    {
      name: "redirectURLs",
      type: "string[]",
      description: "Array of of redirect uris",
      isRequired: true
    },
    {
      name: "tokenEndpointAuthMethod",
      type: "string",
      description: "Indicator of requested authentication method for the token endpoint. Supports: ['none', 'client_secret_basic', 'client_secret_post']",
      isOptional: true,
    },
    {
      name: "grantTypes",
      type: "string[]",
      description: "Array of supported grant types. Supports: ['authorization_code', 'authorization_code', 'refresh_token']",
      isOptional: true,
    },
    {
      name: "responseTypes",
      type: "string[]",
      description: "Array of supported grant types. Supports: ['code']",
      isOptional: true,
    },
    {
      name: "public",
      type: "boolean",
      description: "Indication if the client is confidential or public",
      isOptional: true,
    },
    {
      name: "type",
      type: "string",
      description: "Type of OAuth client. Supports: ['web', 'native', 'user-agent-based']",
      isOptional: true,
    },
    {
      name: "metadata",
      type: "string",
      description: "Additional metadata for the OAuth client",
      isOptional: true,
    },
  ]}
/>

### Session

Table Name: `session`

Extends the native [`session`](/docs/concepts/session-management) table.

<Callout type="warn">
The original required `token` field is now marked as optional.
</Callout>

<DatabaseTable
  fields={[
    {
      name: "refresh",
      type: "string",
      description: "A hashed/encrypted refresh token",
      isOptional: true,
    },
    {
      name: "clientId",
      type: "string",
      description: "ID of the OAuth client",
      references: { model: "oauthApplication", field: "clientId" },
      isOptional: true,
    },
    {
      name: "scopes",
      type: "string[]",
      description: "Array of granted scopes",
      isRequired: true,
    },
  ]}
/>

### OAuth Access Token

Table Name: `oauthAccessToken`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the opaque access token",
      isPrimaryKey: true
    },
    {
      name: "token",
      type: "string",
      description: "Hashed/encrypted access token",
    },
    {
      name: "clientId",
      type: "string",
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthApplication", field: "clientId" }
    },
    {
      name: "sessionId",
      type: "string",
      description: "ID of the user associated with the token",
      isForeignKey: true,
      references: { model: "session", field: "id" },
    },
    {
      name: "scopes",
      type: "string[]",
      description: "Array of granted scopes",
      isRequired: true,
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp when the access token was created" 
    },
    {
      name: "expiresAt",
      type: "Date",
      description: "Timestamp when the token will expire",
    },
  ]}
/>

### OAuth Consent

Table Name: `oauthConsent`

<DatabaseTable
  fields={[
    {
      name: "id",
      type: "string",
      description: "Database ID of the consent",
      isPrimaryKey: true
    },
    {
      name: "userId",
      type: "string",
      description: "ID of the user who gave consent",
      isForeignKey: true,
      references: { model: "user", field: "id" }
    },
    {
      name: "clientId",
      type: "string",
      description: "ID of the OAuth client",
      isForeignKey: true,
      references: { model: "oauthClient", field: "clientId" }
    },
    {
      name: "scopes",
      type: "string",
      description: "Comma-separated list of scopes consented to",
      isRequired: true
    },
    {
      name: "consentGiven",
      type: "boolean",
      description: "Indicates if consent was given",
      isRequired: true
    },
    {
      name: "createdAt",
      type: "Date",
      description: "Timestamp of when the consent was given" 
    },
    {
      name: "updatedAt",
      type: "Date",
      description: "Timestamp of when the consent was last updated"
    },
  ]}
/>

## Options

### Prefix

Add a prefix to either or both opaque access tokens or refresh tokens. This is useful for Secret Scanners (ie. [GitHub Secret Scanners](https://docs.github.com/code-security/secret-scanning), [GitGuardian](https://www.gitguardian.com/solutions/secrets-scanning), [Trufflehog](https://github.com/trufflesecurity/trufflehog)) that may rely on the prefix to help determine the token format.

**opaqueAccessTokenPrefix**: `string | undefined` - add a prefix onto opaque access tokens
**refreshTokenPrefix**: `string | undefined` - add a prefix onto refresh tokens

## Optimizations

To improve lookup performance, map the field `client_id` on the table `oauthApplication` to `id` through your database adapter.

## Migrations

### From [OIDC Provider](/docs/plugins/oidc-provider)

#### Configuration

- **`idTokenExpiresIn`** now defaults to `10 hours` (previously `1 hour` through `accessTokenExpiresIn`)
- **`refreshTokenExpiresIn`** now defaults to `30 days` (previously `7 days`)
- **`advertisedMetadata`** (previously `metadata`) no longer supports changing metadata fields to prevent accidental misconfiguration.
- **`clientRegistrationDefaultScopes`** (previously `defaultScope`) is now in array format instead of a space-separated string
- **`consentPage`** is now required
- **`getConsentHTML`** is removed in favor of the `consentPage` as raw html is not a response type supported by the authorize endpoint in oAuth
- **`requirePKCE`** is removed as PKCE is required in oAuth2.1
- **`allowPlainCodeChallengeMethod`** is removed as the `plain` code challenge is considered less secure than the default `S256` method
- **`getAdditionalUserInfoClaim`** removes the client object as a parameter
- **`storeClientSecret`** now defaults to `hashed`, or `encrypted` if `disableJWTPlugin: true` (previously `plain`).
- JWT plugin now is enabled by default. To disable the plugin, set `disableJWTPlugin: true`.
- Authorization query `code_challenge_method` "S256" must be in caps as described by oAuth 2.1

#### Database

##### Table: `oauthApplication`

- If `storeClientSecret` was unset or `plain`, you must hash all the stored `clientSecret` values into its "SHA-256" representation then convert it into base64Url format or use another storage method specified by `storeClientSecret`.
- `type` field is no longer a required field. Instead, the schema requires `public` of type `boolean`. Migrate with the following rules:
    - Clients with `type: "public"`: set `type: undefined`, `public: true`, and `clientSecret: undefined`
    - Clients with `type: "native"`: set `public: true` and `clientSecret: undefined`
    - Clients with `type: "user-agent-based"`: set `public: true` and `clientSecret: undefined`
    - Clients with `clientSecret: undefined`: set `public: true`
- `redirectURLs` renamed to `redirectUris`
- `metadata` is now stored in database as individual fields instead of a JSON object. Parse the metadata into their respective fields. The OIDC plugin did not utilize this field but this oAuth plugin may utilize them in the future.

##### Table: `oauthAccessToken`

Option 1 (simple):

You may choose to opt-out of this table conversion with minimal impact. By doing so, existing users will simply need to login again. Simply delete the existing table `oauthAccessToken`.

Option 2 (more complex):

- Convert all `oauthAccessToken` to a `Session` using the following map:
```ts
{
  refresh: hashed(refreshToken),
  expiresAt: refreshTokenExpiresAt,
  clientId: clientId,
  scopes: scopes,
  userId: userId,
  createdAt: createdAt,
  updatedAt: updatedAt,
}
```
- Map all `oauthAccessToken`:
```ts
{
  token: hashed(accessToken),
  expiresAt: accessTokenExpiresAt,
  clientId: clientId,
  scopes: scopes,
  userId: userId,
  createdAt: createdAt,
  updatedAt: updatedAt,
}
```


### From [MCP Provider](/docs/plugins/oidc-provider) to this oAuth2.1 provider

The MCP endpoints moved from `/mcp` to the `/oauth2` equivalent.

- `/oauth2/authorize` (previously `/mcp/authorize`)
- `/oauth2/token` (previously `/mcp/token`)
- `/oauth2/register` (previously `/mcp/register`)
- `/mcp/get-session` removed as not oAuth2 compliant, use `/oauth2/introspect` instead
- `/.well-known/oauth-protected-resource` removed, use the helper `mcpHandler` (or manually with `checkMcp` and `handleMcpErrors`)


### From [API Key](/docs/plugins/api-key)

This oAuth plugin provides additional security benefits over API Keys such as short-lived access tokens, key rotation, and centralized revocation.

While we are currently unable to fully migrate the API Key schema and its functionality at this time, here are some implementation tips to assist in migration:

#### Database
  - API `permissions` should convert into `scopes`. However, you may wish to define `scopes` as a group of `permissions`, just depends on your implementation.
    - NOTE: the following `scopes` are reserved: 'openid', 'profile', 'name', 'email', 'phone', 'address'.

#### Setup
  - Register an oAuth client with `scopes` (previously `permissions`).
  - Store the `client_id` and `client_secret`(previously `api_key`) in your client's environment.

#### Client
For user-scoped data:
  - Request authorization using the `authorization_code` with PKCE flow.
    - Authorize first at `/oauth2/authorize`.
    - At the callback, exchange the `code` for `tokens`
  - Access token can be used to perform scoped actions
  - If requested with a `offline_access` scope, you use the `refresh_token` to obtain new tokens. Save this in your database alongside the user that authorized it.
    - Request a new token whenever the `access_token` expires using the `refresh_token` grant at the `/oauth2/token` endpoint
    - To obtain a JWT-formatted token, you must request using the `resource` parameter again.

For machine-to-machine communication:
  - Request a token using the `client_credentials` grant at the `/oauth2/token` endpoint
  - Store the token in memory
    - Request a new token whenever token expires

#### API Server

##### JWT Access Tokens Only (Recommended)

Simplify your API authentication by only accepting JWKS-verifiable JWT access tokens. Opaque tokens should be denied. JWT Tokens can be requested using the `resource` parameter at the `/oauth2/token` endpoint.

**Benefits**:
  - Fast: locally-verifiable
  - Future-proof: fully independent from the authorization server (no better-auth config needed)
  - API does not require `client_secret` or admin access to inspect the token's content

**Verification Steps**:
  - Verify token is valid. Check `iss` and `aud` fields against your `jwks`.
  - Validate appropriate `scope` per endpoint

##### JWT and Opaque Access Tokens

Accept both JWT and Opaque Access Tokens via the `/oauth2/introspect` endpoint.

**Benefits**
  - Immediate token and client validation
  - Client doesn't require `resource` parameter

**Pitfalls**
  - Secret Required: Requires a `client_secret` not available for public clients.
    - NOTE: Introspection Bearer token and Private Key JWT methods are not yet implemented either
  - Database Access: Every token received requires a database search.

**Verification Steps**:
  - Send received token to `/oauth2/introspect` and assert returned `active: true`.
  - Validate appropriate `scope` per endpoint
